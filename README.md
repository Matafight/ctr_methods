# ctr_methods

## 常用的ctr方法：
1. logistic regression
2. ftrl
3. fm
4. ffm
5. deepfm

## 什么是点击率预估？
ctr的主要任务是预测用户点击某个广告的概率，一般是一个二分类问题，通常需要面对海量的样本和特征，所以算法的效率和性能都比较关键。

## 评估指标是什么？
以kaggle上的一个比赛为例(https://www.kaggle.com/c/outbrain-click-prediction/overview/evaluation)， 该比赛的任务是给定 display_id和ad_id，判断用户点击这个ad_id的概率（display_id应该是与用户相关的），该任务采用的评估指标是 MAP@12(mean average precision)，具体的公式如下所示：
![pic1](https://img2018.cnblogs.com/blog/667947/201908/667947-20190825213519534-935687563.png)
其中|U|是总的display_id的数目，|n|是预测的ad_id的数目，k是cutoff，p(1)表示取每个display_id里得分最高的ad_id看准确率，所以p(k)就表示取每个display_id中概率最高的前k个ad_id作为候选，判断其中有没有用户真实点击的ad_id，并计算准确率。

## 常用算法比较：
 1. lr
    优点：简单，高效
    缺点：线性模型，无法自动处理特征间的交叉关系，需要手动做特征工程
2. fm
    在lr的基础上加入了自动对特征间的交叉关系建模的二阶特征，避免了手动特征工程的繁琐，每个特征都需要学习一个k的隐空间向量，特征两两之间的交叉项系数等于对应特征隐空间向量的内积。
3. ffm
    由于ctr预估中的特征通常都是离散的，所以通常需要对特征做one-hot编码，所以可以对one-hot的编码特征进行分组（分为多个field），由同一个原始特征编码出来的one-hot特征属于同一个field。假设有k个field，之前在fm中每个特征都只需要学习一个隐空间向量，这就意味着这个特征在与其他不同field特征相交叉时用的是同一个隐空间向量进行内积。ffm的做法是对每个特征都学习k个隐空间向量，这样每个特征在与其他各个不同field的特征交叉时能自适应得学习到最优的隐空间向量，ffm的参数明显比fm多，所以ffm模型的表达能力比fm强。
4. ftrl
    ftrl算法是基于多个算法发展而来，我从头捋一遍（参考冯扬的《在线最优化求解》，具体细节可以看那篇文章）：
    1. L1正则化法
        梯度下降时对L1范数用的是次梯度进行更新，而这会导致求得的系数没有稀疏性。
    2. 简单截断法
        每隔K步(t mod K = 0 )都对梯度进行一次截断，其他步（t mod K !=0）按照一般的梯度下降更新参数（不考虑L1范数）
    3. 截断梯度法(TG)
         截断梯度法与简单截断法比较像，也是每隔K步进行截断，其他步是常规更新参数，与简单截断法不同的是，TG采用的截断函数不同 
        ![](https://img2018.cnblogs.com/blog/667947/201908/667947-20190825220709648-386857884.png)

    4. FOBOS，RDA和FTRL算法
        这里这要对比这几种算法的优缺点：
![](https://img2018.cnblogs.com/blog/667947/201908/667947-20190825221007068-1320505901.png)
![](https://img2018.cnblogs.com/blog/667947/201908/667947-20190825221056300-852749607.png)
![](https://img2018.cnblogs.com/blog/667947/201908/667947-20190825221113258-78795624.png)
      总结一下就是：FOBOS的优点是限制了W的变化不能离已迭代得到的解太远，缺点是产生的解相比RDA求得的解稀疏性不足，且其每次判断是否对每个维度进行截断时只考虑了当次迭代该维度的梯度变化，而RDA则考虑了过去所有迭代该维度梯度变化的平均值，避免了由于当此迭代该维度训练不足引起的梯度截断。RDA的缺点是只限制了W的变化不能离0点太远，而FTRL则结合了FOBOS和RDA的优点。

5. DeepFM
    本身原理比较好理解，代码写起来比较困难，https://blog.csdn.net/w55100/article/details/90295932 这篇博客写的很好

